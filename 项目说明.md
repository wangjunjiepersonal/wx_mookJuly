## 项目结构
	
components 组件文件夹 
	
	book组件  用来渲染书籍页的单独一本图书 接收的参数为Object图书对象中的图书id 跳转后传递给详情页
		作用	渲染单独的一本图书  点击跳转到图书的详情页 跳转方式 wx.navigateTo
		
	episode组件 用来渲染首页左上角的日期  接收的参数为String 索引 用来显示当前的页面索引 并激活properties中的observer方法 进行补零操作
		作用 	用来显示当前的日期 
				对于日期的操作: 在组件页面的生命周期函数attached中 获取当前的年、月 对于月的操作为设置一个12个月的数组months 由于英文的月比中国的少一个月	
				通过months[当前月] 通过索引的方式选择设定我们中国的当前月份  简单的方法为 英文的当前月+1 
						
	img_btn组件 承载获取用户信息的button按钮 接收的参数为String 是否获取用户信息的属性
		作用	与用户交互请求获取用户信息 通过自定义事件将获取的用户参数传递给my组件
	
	index文件夹下面的essay movie music 组件 用来渲染首页左中区域的文字 接收的参数封装在	classic-beh.js文件中	 	
		作用  	用来渲染首页页面文字 通过接收不同的type值来判断指定的渲染文字
				唯一不同 music文件虽然渲染首页文字 但其组件同样控制音乐播放 接收的参数为音乐的播放路径和音乐的标题
				music文件 渲染首页文字 控制音乐播放
					在点击播放按钮后 更换播放状态的图片 如果音乐播放的状态为false 则将播放状态改为 true 反之则关闭音乐 （切换状态按钮的意思）
					对音乐播放状态的控制  在存在音乐的页面加载后 首先判断当前音乐播放控制的播放状态paused 意思就是加载当前页面时 音乐不能自动播放
					如果当前触发了该页面的音乐播放事件 则将该页面音乐的播放状态设置为true 可以播放音乐 相当触发了播放事件后才可以播放 
					音乐播放状态的控制  判断程序缓存中的音乐播放状态 分别是 onPlay onPause onStop onEnded  播放 关闭 暂停 退出
					均通过音乐播放状态的控制来判定  _recoverStatus()
					如果当前有音乐播放   自己是不能播放的 
					如果当前没有音乐播放 自己是不能播放的 
					如果当前音乐暂停播放 自己是不能播放的
					如果当前退出音乐播放 自己是不能播放的
	index文件夹下面的 classic-beh.js 文件 通过将 essay movie music 组件中共用的参数接收封装在Behavior文件中 通过其他组件引用获取相应的值
	index文件夹下面的 common.wxss 文件	 essay movie music 组件中共用的wxss属性	
	
	like组件 首页右上角喜欢显示 书籍搜索页底部显示  个人中心页面喜欢区域显示 用来标注是否喜欢
		作用	标注喜欢的状态及喜欢的人数 接收的参数有 是否喜欢like 喜欢的人数count 是否可以通过点击事件取消喜欢状态readOnly
					第三个参数的作用在于 在个人中心my组件中 会将自己喜欢的期刊项目呈现出来 
					这时呈现出来的项目是红心(也就是喜欢状态)在这个页面中不可以直接点击将期刊项目变为不喜欢 需要在期刊项目原始的页面中点击才可以变为不喜欢
				内部事件 点击切换喜欢/不喜欢状态 切换图片显示 自定义事件 向父组件发送点击后当前的喜欢状态通过点击事件传递给父组件  分为喜欢和不喜欢
	
	loading组件 等待效果组件 用来在数据请求的过程中显示 数据请求回来后消失
		这个组件没有参与js运算 只是在相应的页面通过wx:if来判断显示 用处为书籍搜索页的下拉加载功能以及搜索结果列表显示的功能
	
	mask遮罩组件 遮罩效果组件 用来在数据内容是更容易聚焦 将其他渲染的内容进行视觉屏蔽
		这个组件没有参与js运算 只是在相应的页面通过wx:if来判断显示  用处为书籍书本详情页 跟随底部的评论框一同弹出来
	
	navi组件  首页下方的切换组件 通过左右点击切换显示不同的页面 
		作用	用来点击左右按钮触发事件切换首页的列表项 接收的参数有 当前的标题title 最新一期latest 第一期 first 
				为左右切换按钮设置点击事件 onLeft onRight 
				判断父组件传递过来的first和latest的值 在二者的事件中自定义事件 将左右按钮的点击事件传递给父组件 
				如果最新一期latestlatest的值为false 意思不是最后一期 还可以向左点击获取最新的期刊
				如果第一期first的值为false 意思不是最后一期 还可以向右点击获取最新的期刊
				这里的判断与平常不同 第一期first在此时是最老的 而latest确实最新的 就好像数字1是第一 后面的数字排到后面却是新的
	
	preview组件 在个人中心my组件中用来渲染自己喜欢的期刊项目 
		作用	渲染自己喜欢的期刊项目列表 接收的参数为 classic对象 里面存储的是单个的期刊项目数据 组成的结构有标题 是否喜欢 图片
				通过properties.observer来过滤自己创建的typeTex属性 通过data.typeText来接收过滤的数据  分别为 电影  音乐 句子 
				根据传入的type数据 来判定是否为 '200' 就是是否为music组件 返回结果为true话图片裁剪为圆形展示
		未实现事件  在点击了单个的渲染项目后 将跳转到渲染自己喜欢的期刊项目的期刊详情页 原项目为 classic_detail页面 传递过去的为当前项的id和type
	
	search组件  书籍页的搜索组件 包含数据搜索 展示搜索结果 点击取消返回书籍页面
		作用	分别有 显示历史搜索和热门搜索  搜索书籍向后台请求数据  展示搜索回来的数据  通过上拉加载更多数据
				接收的参数为 more 就是上拉加载的触发元素 由于上拉加载只在页面中有效 所以要将父组件页面中的上拉加载状态动态的传递给子组件 
					这样页面一旦触发上拉加载 组件就会动态的接收到相应的值执行上拉加载更多的操作  
					如果通过properties.observer来触发上拉加载的操作操作给子组件 需要动态传递一个实时不同的数据给子组件 比如时间 或者随机字符串等
					这个方法为 _load_more() 他会首先判断有没有搜索结果 有没有加载loading功能 如果没有则直接返回不再操作
					在有更多数据的情况下 hasMore() 在触发了上拉加载数据后 通过bookModel.search()方法继续请求数据 并通过paaination.js将数据进行格式化
				历史搜索的数据是我们将搜索框内的数据通过wx.setStorageSync缓存到本地  最大显示10条
				热门数据在页面生命周期函数attached加载后 立即获取热门数据并展示在组件页面中
				通过paaination.js加工对书籍搜索数据功能和上拉加载功能的实现  分别有 
					在上拉加载数据后 将之前存储的数据与此次请求回来的数据拼接后渲染显示
					获取请求回来的数据长度总和 
					判断是否有更多数据 通过这个来判断后台的数据还有多少 避免在数据都返回给前台后依旧发送无效请求给后台
					获取后台数据的最大条数 获取后台数据的某个数据总和
					清空之前保存的数据  在更改了关键词搜索后 数据重新请求并渲染页面 在渲染之前 将之前上次请求渲染的数据与储存数据的变量清空
				搜索框的搜索事件 该事件为主要事件 在触发了搜索事件后 将书籍页面的书籍列表隐藏 显示搜索组件的列表 同时将搜素结果的存储对象dataArray滞空
				获取搜索的结果属性 q 无论是点击下方的历史/热门搜索组件还是输入的数据 均通过q属性进行存储
				渲染第一页的数据 数据量为20条 关键词为q 在返回结果后 通过将数据通过paaination.js方法加工
				点击x按钮清除搜索关键词 并返回搜索页面 并清除之前的搜索记录数据 之前在搜索列表的结果页面
				在搜索数据请求回来之后 将历史搜索与热门搜索通过wx:if进行隐藏 页面展示搜索结果的数据列表
				loading的加载  loading功能与数据功能的相反的  在数据未请求回来之前 显示loading 请求回来之后 取消loading
	
	tag标签 显示按钮格式的文本  接收一个text参数	这个参数是该标签的文本信息
		作用	显示按钮格式的文本 接收的参数是父组件传递过来的文本 同时还有自定义点击事件 onTap 点击后将事件发送给父组件 传递的值为当前按钮的文本
		该功能有插槽 插槽的功能用于显示书籍详情页book-detail的评论数量 	
		
models 封装数据请求操作文件夹 用来封装各个页面的异步请求函数  以增加粒度减少代码的耦合度
	总体思路：
		对后台的异步数据请求有两种模式 一种是以回调函数的方式 一种是Promise方式
		在本项目中 http.js文件是通过回调函数的方式获取数据 http-p.js是通过Promise方式获取数据
		由于数据为同源请求 同时还需要appid密钥 将统一的url路径和appid封装在config.js文件中

	book.js 用来封装书籍页面的异步数据请求
		getHotList()   		获取热门书籍列表
		getMyBookCount() 	获取书籍数量
		getDetail(bid)      获取书籍的详细信息 就是书籍详情页
		getLikeStatus(bid)  获取书籍点赞状态
		getComments(bid)    获取书籍的短评
		postComment(bid,comment)  提交短评内容
		search(start, q)    搜索书籍信息
		
	classic.js 用来封装首页的异步数据请求 回调函数请求数据的方法
		getLatest(callback) 请求最新一期的内容
			该方法只接收一个参数回调函数callback 用来数据请求回来之后 通过callback将数据返回出去
			将请求回来的数据通过_getKey()方法进行加工 获取当前的索引值index
			通过setStorageSync方法本地存储以该索引值命名的数据 这个主要用来进行数据缓存本地化 避免频繁的切换页面重新请求数据造成服务器压力过大
			通过_setLatestIndex方法将该索引以'latest'名称进行存储 以便后面判断是否为最新一期数据
			
		getClassic(index,norp,callback) 请求最新一期和第一期的合写方法
			该方法接收三个参数 索引值 上一期或者下一期的操作 回调函数callback
			首先判断当前的操作是请求上一期还是下一期的操作 通过这个可以获取本地是否已经缓存了这个数据 如果缓存了直接通过回调返回出去 如果没有才发送请求
			获取到了数据 两个方式 一个是从缓存中读取的 一个是从后台获取的 都返回出去
			
		isFirst(index) 	     判断是否为第一期
			判断传入的索引是否为1  因为第一期的索引为1 返回布尔值
			
		isLatest(index) 	 判断是否为最新一期
			最新一期的索引存储在缓存中 命名为'latest' 判断传入的索引是否为'latest'保存的索引 返回布尔值
		
		getMyFavor(callback) 获取喜欢的图书 这个操作是在个人中心my页面中 获取喜欢的页面并渲染
	
	keyword.js 用来缓存search组件的历史信息和请求热门信息
		getHistory()		 获取历史信息  如果没有返回为空
		getHot()			 获取热门数据
		addToHistory(word)   对历史信息数据的加工 
			首先在缓存中查取有没有准备写入的关键字 如果为新的关键词没有被缓存 通过unshift()添加到缓存的第一位 就是在第一个显示最新的
			检测缓存的长度 如果大于10个 就删除末尾的一个 为新的关键词腾位子
			
	like.js 对是否喜欢按钮的显示操作
		like(behavior,artID,category) 是否喜欢的操作 
			接收三个参数  将更改的喜欢状态传入后台缓存起来 下次打开页面就是新的喜欢状态了
				behavior点击了喜欢还是不喜欢 这是从子组件传入的自定义事件 
				artID 当前项的id值 其实就是当前项的索引 
				category 当前项的type值 也就是期刊100 歌曲200 句子300的分类
				
		getClassicLike(artID,category,callback)	喜欢按钮的单独请求 
			 由于前期进行了数据本地化的操作 但对于动态的数据必须喜欢的状态 需要重新进行请求 以免在喜欢状态更改之后 由于本地化缓存没有更新数据导致显示错误
			 这也说了之前的 本地化数据适用于静态数据的缓存处理 对于动态的数据并不适用于本地化保存数据 这里单独设置了一个请求接口 请求喜欢的实时状态
			 
page	主要的页面
	index 首页	
		导入classic.js和like.js模块 实例化相关的类 用来处理数据请求操作和喜欢的状态更改
		通过调用getLatest()方法 获取最新一期的数据渲染到页面上 更新的属性有 接收的数据 喜欢的状态  喜欢的数量 
		点击喜欢还是不喜欢切换  这个事件由 传递的属性值为喜欢的状态 like/cancel 更新到后台
		左右的按钮喜欢  更新上一期onPrev(e)或者下一期onNext(e)的期刊  
			点击后调用_updataClassic()按钮的请求封装方法 传入'next'/'previous' _updataClassic()方法中 
				在方法内部 调用getClassic()方法回去下一张的信息 同时在回调函数中更新切换后的喜欢状态 更新相关的接收的数据 喜欢的状态  喜欢的数量 
		
	book  书籍页
		导入book.js和random.js模块 实例化相关的类 用来处理数据请求操作和设置随机字符串操作
		在页面的生命周期函数onLoad中 通过getHotList()方法获取书籍页的相关信息
		在点击搜索框后 表示已经进入了搜索页面 这时要搜索的页面的状态设置为true 原本的书籍页设置为false隐藏
		点击了子组件传递过来的取消按钮后 将搜索的页面的状态设置为false隐藏 原本的书籍页设置为true显示 
		在触发了上拉加载事件后 向搜索组件传递more参数 值为十位数的随机数random(10) 用来实时触发more的修改 
		
	book-detail 书籍详情页
		导入book.js和random.js模块 实例化相关的类 用来处理数据请求操作和设置随机字符串操作
		在生命周期函数onLoad中 获取传过来的options.bid 渲染完成前显示loading等待功能
		通过Promise.all获取书籍的详细信息 书籍的评论 喜欢的状态 喜欢的数量 加载完成后隐藏loading等待功能
		点击喜欢/不喜欢按钮后 将更改的信息发送给后台 这次带400参数 虽然不知道是什么意思
		点击评论输入框后 弹起评论组件 将评论组件的状态posting设置为true显示评论组件
		点击评论输入框右上角的取消按钮后 将评论组件的状态posting设置为false隐藏评论框
		在点击评论标签tag组件或者通过点击手机的确认按钮触发的bind:confirm事件后 获取评论的内容 comment
			检测评论的长度 不能超过12个字 或者不能是空的 验证不通过返回return 
			验证通过后 通过postComment()向后台发送评论数据 参数为书籍的id  评论的内容 
			发送成功后 通过unshift()将刚发送的评论内容添加到评论组件数组 添加的是对象格式  一个是评论的内容 一个是nums 右上角的数字小标
		wxml页面的wxs标签 只能用es5 注意module="util" 引用时需要通过 util.xxx执行
			limit方法 		 截取前15条评论
			format方法       用来处理/n不换行的问题 通过getRegExp()方法 微信自带的正则表达式 
			heightlight方法  处理自定义样式
			 
	my    个人中心页
		  导入classic.js和book.js模块 实例化相关的类 用来获取喜欢的收藏列表和书籍的渲染
		  在页面生命周期函数onLoad中 检测用户是否授权获取个人信息 获取喜欢的书籍数量 渲染喜欢的书籍列表
		  因为在个人中心页面需要获取用户的信息 需要用到 button的open-type属性 获取用户的相关信息
		  通过wx.getSetting()方法检测用户是否授权 如果已经授权 通过成功的回调函数 authSetting['scope.userInfo'] 获取用户具体信息
		  在点击了获取按钮后 通过img-btn的自定义事件 e.detail.userInfo 获取用户具体信息
		  通过getMyFavor()方法获取喜欢的书籍 通过wx:for循环出来
		  点击了关于我们按钮后通过wx.navigateTo()跳转新页面  讲师自己做的小广告
		  点击了右上方图片后通过wx.navigateTo()跳转新页面  讲师自己做的小广告 
		 
	course 课程的广告页 就是一张图片 
	about  跳转页 跳转到其他小程序页面  关键点为target="miniProgram" app-id="wx8ffc97ad5bcccc89"	这两个属性

utils文件夹  存放http请求  
	http-p 通过Promise方式发送异步请求 
		引入全局属性 config 
		创建类 Http 设置方法 request 传入的参数有 url请求地址 data数据 method请求方式 
		创建Promise类直接返回 在使用时直接可以通过.then()进行返回数据的处理
		通过wx.request()进行请求 传入的参数有 url data header method success fail
			在成功的回调success 检查返回的code值 如果返回的值是'2'开头的 意思就是代表成功  通过Promise类的resolve返回数据
			在失败的回调fail 执行reject() 检查是否返回了相关的错误如果没有则自己设置错误值 如果返回是设置好的参数 则通过wx.showToast()报对应的错误  
	http 通过回调番薯方式发送异步请求
		基本逻辑与http-p一样  只是 http-p通过resolve返回数据 而http通过params.success(res)返回数据
	random.js 返回随机字符串
		返回随机的字符串给 more 这样每次上拉刷新请求数据 都可以激活properties.observer方法 实时监控上拉加载的状态
		
	app.json   设置页面的路由以及"tabBar"
		
	config.js  设置全局属性  一个是同源路径的地址  一个是appid密钥 
	
项目难点	
	组件化 将项目中超过2个以上相同的功能区域封装为组件调用 简化开发
	模块化 将数据的请求操作封装在单独的工具js文件中 与页面js功能分离 减少耦合与增加复用
	
	Behavior 
		组件的继承机制  设置单独的Behavior文件 可将组件通用的参数接收、事件处理、data属性等进行统一资源处理 组件引用该文件即可使用其中的属性
	wx.getBackgroundAudioManager() 
		音乐播放控件 需要传入必要的音乐播放地址src和音乐标题title 
		可以判断系统缓存中的音乐播放状态 分别有 onPlay onPause onStop onEnded  当前播放 当前关闭 当前暂停 当前退出
		
	将服务器的数据本地化  好像vue的keep-alive方法一样 对于已经请求过的数据不再重复进行请求
		目的主要用来减少服务器的压力  对于频繁切换的静态化数据适用于数据本地化
		方法是将请求回来的数据通过该数据的id或者索引命名存储在缓存中  
			在切换页面读取数据时 首先判断缓存中是否有数据 有的话直接从缓存中读取数据 如果没有的话从服务器读取数据 将该数据存储在缓存中
			
	Promise.all方法 将用处相同的请求方式相同的方法合组为一个方法 通过Promise.all进行管理	
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		